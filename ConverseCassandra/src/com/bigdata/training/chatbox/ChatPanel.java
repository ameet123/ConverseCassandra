package com.bigdata.training.chatbox;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.HierarchyEvent;
import java.awt.event.HierarchyListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;

import org.apache.log4j.Logger;
import com.bigdata.training.cassandra.OneMessage;
import com.bigdata.training.cassandra.SpeakCassandra;
import com.bigdata.training.cassandra.Statics;
import com.bigdata.training.cassandra.Utility;

/**
 * Extends JPanel and adds other components to display a conversation
 * in a progressive and chronological manner
 * @author ameet
 */
public class ChatPanel extends JPanel  {
	private static final long serialVersionUID = -4349515247584535734L;
	/**
	 * Split Pane to host messages from two people side by side
	 */
	private JSplitPane split ;
	/**
	 * Button to fetch the next message chronologically
	 */
	private JButton fetchNext;
	/**
	 * Label that displays messages from speaker 1
	 */
	private JLabel speaker1Message;
	/**
	 * Label that displays messages from speaker 2
	 */
	private JLabel speaker2Message;
	/**
	 * Scroll panel for speaker 1
	 */
	private JScrollPane speaker1Pane;
	/**
	 * Scroll panel for speaker 2
	 */
	private JScrollPane speaker2Pane;
	/**
	 * to store instance of Cassandra speak in order to perform
	 * all the functions
	 */
	private SpeakCassandra cassSpeak;
	private String talker1;
	private String talker2;
	/**
	 * to log log4j messages
	 */
	private Logger log;
	
	/**
	 * Constructor performs all the work and returns a component which is of Type JPanel
	 * @param talker1
	 * @param talker2
	 */
	public ChatPanel(String talker1, String talker2){	
		// get Logging framework going
		log = Logger.getLogger(ChatPanel.class.getName());
		log.info("starting "+this.getClass().getName()+" ...");
		
		// Store the passed parameters into instance variables
		// so we can refer to them for getting next message
		this.talker1 = talker1;
		this.talker2 = talker2;
		
		/**
		 * define label to contain actual messages
		 */
		speaker1Message = new JLabel();	
		// Now set its name to the one passed so we can identify which Pane is for whom
		speaker1Message.setName(talker1);
		
		speaker2Message = new JLabel();
		speaker2Message.setName(talker2);
		
		/**
		 * create scroll Panel to display messages
		 */
		speaker1Pane = new JScrollPane(speaker1Message);
		speaker2Pane = new JScrollPane(speaker2Message);
		/** 
		 * set preferred sizes of scroll Panes
		 */
		speaker1Pane.setPreferredSize(Constants.PANE_DIMENSION);
		speaker2Pane.setPreferredSize(Constants.PANE_DIMENSION);
				
		/**
		 * define the button to fetch messages and 
		 * add an action listener for it
		 */
		fetchNext = new JButton("Next");
		fetchNext.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				doButtonAction();
			}				
		});	
		/**
		 * create the split panel and set its divider location
		 */
		split = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, speaker1Pane, speaker2Pane);
		split.setDividerLocation(Constants.WINDOW_WIDTH/2);
		split.setOneTouchExpandable(true);
		
		/**
		 * add the title to each pane window
		 */
		addPaneTitle(talker1, talker2);
		/**
		 * add splitPane to the Panel
		 */
		add(split);
		add(fetchNext, BorderLayout.PAGE_END);
		/**
		 * set the size of this Panel window
		 */
		setPreferredSize(new Dimension(Constants.WINDOW_WIDTH, Constants.WINDOW_HEIGHT));
		/**
		 * get an instance of SpeakCassandra
		 */
		cassSpeak = new SpeakCassandra(Statics.KEYSPACE);
		
		// Cleanup
		/**
		 * This is logical but a bit convoluted.
		 * What are we trying to do: We need to close Cassandra connections when the main window closes
		 * How: When the window closes, a windowClose event is generated by the JFrame.
		 * Problem: we need to get that event inside the JPanel, since that's where we have the reference
		 * 			to the SpeakCassandra Object
		 * Approach: 1. We register a "HierarchyChanged" event for the JPanel component. That tells us
		 * 			 when the ancestry of the JPanel changes, i.e. when it is added to a JFrame.
		 * 			 2. based on that event, we register a windowClose event and remove listening for further hierarchy
		 * 				changes
		 * 			 3. in that windowClose event, we close the Cassandra connections.
		 */
		this.addHierarchyListener( new HierarchyListener() {
			@Override
			public void hierarchyChanged(HierarchyEvent e) {
				log.debug("Hierarchy of JPanel changed, adding windowClose now...");
				boolean connected = setupListenersWhenConnected();

                if (connected) {
                	log.debug("We, the JPanel, were really added to a JFrame, removing further hierarchy change listenings..");
                    ChatPanel.this.removeHierarchyListener(this);
                }
			}			
		});		
	}
	/**
	 * Method to register windowClose events and close cassandra connections
	 * @return	boolean
	 */
	protected boolean setupListenersWhenConnected() {
        JFrame parentFrame = (JFrame) SwingUtilities.getWindowAncestor(this);
        if (parentFrame == null) {
            return false;
        }
        parentFrame.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                // Implementation here
                log.debug("JFRAME is closing, let's close Cassandra connections!");
                cassSpeak.close();
            }
        });
        return true;
    }	
	/**
	 * define the action to perform when "Next" button is pressed
	 */
	public void doButtonAction(){
		String curText = null;
		
		// get One Message from our Cassandra Speak Object
		OneMessage theMessage = cassSpeak.getNext(Statics.CONVERSATION_CF, talker1, talker2);
		// get the talker out of it and the message
		String newMessage = theMessage.getMessage().trim();
		String theTalker = theMessage.getTalker();
		String messageTime = theMessage.getMessageTime();
		// format the time in html
		messageTime = Utility.formatTimeInHTML(messageTime);
		// append this formatted time to the message
		newMessage = newMessage + messageTime;
		
		// debug
		log.debug("thus spake Cassandra:"+newMessage);
		log.debug("the talker was per Cassandra:"+theTalker);
		
		/**
		 * Now, we need to find out who the talker is under consideration and get HER/HIS
		 * message so we have appropriate "original" value to append to
		 */
		if (speaker1Message.getName().equals(theTalker)){
			curText = speaker1Message.getText();
		} else if (speaker2Message.getName().equals(theTalker)){
			curText = speaker2Message.getText();
		}

		String p = "<html>(.*?)</html>";
		Pattern r = Pattern.compile(p);
		Matcher m = r.matcher(curText);
		String newText = null;
				
		if (m.find()){
			newText = m.group(1);
			log.debug("WITHOUT HTML:"+newText);
			newText = "<html>"+newText +"<br/>"+ newMessage+"<br/></html>";
		} else {
			// probably first time, set the curText 
			newText = "<html>"+newMessage+"<br/></html>";
		}
		log.debug("New Text:"+newText);
		
		// send the message to right window
		if (speaker1Message.getName().equals(theTalker)){
			log.debug("Matched talker: talker1");
			speaker1Message.setText(newText);
		} else if (speaker2Message.getName().equals(theTalker)){
			log.debug("Matched talker: talker2");
			speaker2Message.setText(newText);
		}
		
		
		
	}
	/**
	 * format the title for each pane window
	 * @param first
	 * @param second
	 */
	public void addPaneTitle(String first, String second){
		Font f = new Font("Serif",Font.BOLD,14);
		
		JLabel t1 = new JLabel(first.toUpperCase());
		t1.setPreferredSize(Constants.PANE_LABEL_DIMENSION);
		t1.setHorizontalAlignment(SwingConstants.LEFT);
		t1.setFont(f);
		t1.setForeground(Color.RED);
		
		JLabel t2 = new JLabel(second.toUpperCase());
		t2.setPreferredSize(Constants.PANE_LABEL_DIMENSION);
		t2.setHorizontalAlignment(SwingConstants.RIGHT);
		t2.setFont(f);
		t2.setForeground(Color.RED);
		
		add(t1,BorderLayout.PAGE_START);
		add(t2,BorderLayout.PAGE_START);
	}
}